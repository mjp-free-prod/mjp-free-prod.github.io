const a=r=>{if(typeof r=="object"&&r!==null){if(typeof Object.getPrototypeOf=="function"){const t=Object.getPrototypeOf(r);return t===Object.prototype||t===null}return Object.prototype.toString.call(r)==="[object Object]"}return!1},e=(...r)=>r.reduce((t,n)=>{if(Array.isArray(n))throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");return Object.keys(n).forEach(o=>{["__proto__","constructor","prototype"].includes(o)||(Array.isArray(t[o])&&Array.isArray(n[o])?t[o]=e.options.mergeArrays?e.options.uniqueArrayItems?Array.from(new Set(t[o].concat(n[o]))):[...t[o],...n[o]]:n[o]:a(t[o])&&a(n[o])?t[o]=e(t[o],n[o]):t[o]=n[o]===void 0?e.options.allowUndefinedOverrides?n[o]:t[o]:n[o])}),t},{}),i={allowUndefinedOverrides:!0,mergeArrays:!0,uniqueArrayItems:!0};e.options=i;e.withOptions=(r,...t)=>{e.options=Object.assign(Object.assign({},i),r);const n=e(...t);return e.options=i,n};function c(r,t,n){const o={},p={};for(const s of t)o[s]=r.columns[s],p[s]=r.labels[s];return e({...r,columns:o,labels:p},n??{})}export{c as p};
